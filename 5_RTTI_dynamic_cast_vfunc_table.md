## $5.4 RTTI and dynamic cast

`dynamic_cast` - это cast который происходит в runtime. Это позволяет проверять корректность преобразования типов.
`static_cast` производит приведение типов в compile-time. Здесь нет проверки на корректность и это может привести к UB.

Обработка ошибок при использовании`dynamic_cast`:
1. При приведении ссылок: Если преобразование невозможно, будет выброшено исключение `std::bad_cast`, которое можно поймать и обработать.
2. При приведении указателей: Если преобразование не удается, возвращается`nullptr`.

Пример кода:
```
struct Base {
    int x = 0;
    virtual void() {}
    virtual ~Base() = default;
};

struct Derived: Base {
    int y = 0;
    void f() overrid {}
};

int main() {
    Derived d;
    Base& b = d;
    Derived* pd = dynamic_cast<Derived*>(&b);
    if (pd) {
        // чет делаем
    }
    return 0;
}
```

`dynamic_cast` применяется только к полиморфным типам.  Так как именно для полиморфных типов в runtime хранится информация какой это тип, оттуда и берется информация для `dynamic_cast`. Полиморфным должен быть именно тот ОТ кого делается каст.

Этот механизм называется `RunTime Type Information(RTTI)`.
Компилятор для полиморфных типов поддерживает спец. структуру в котором хранит, что это за тип на самом деле. Т.е. в каждом полиморфном объекте есть укзатель(скрытый от вас) в котором лежит ссылка на нечто что хранит тип.

В С++ мы можем явно попросить тип объекта. Для этого служит оператор `typeid()`. `typeid()` принимает тип или выражение и возвращается константную ссылку на объект типа `std::type_info`.
Объекты `std::type_info` можно сравнивать между собой с помощью оператора `==`. Для получения названия типа нужно вызвать метод `name()`. Однако имя типа будет иметь немного иной вид понимаемый компилятором.  
Его можно перевести в тип, который использовался в коде с помощью утилиты `c++filt`.
`typeid()` работает и для не полиморфных типов.

Посмотрим на примере:
```
struct Base {
    int x = 0;
    virtual void() {}
    virtual ~Base() = default;
};

struct Derived: Base {
    int y = 0;
    void f() overrid {}
};

int main() {
    Derived d;
    Base& b = d;
    int x;
    std::cout << typeid(x).name() << '\n';
    std::cout << typeid(b).name() << '\n'; 
    return 0;
}
```

Результатом программы будет:  
```
i  
7Derived  
```
Преобразуем в наш читаемый вид:  
`c++filt -t i` результат: `int`.  
`c++filt -t 7Derived` результат: `Derived`.

`dynamic_cast` работает в бок и вниз по иерархии наследования.  
Пример в бок: Сын наследниик мамы и папы. Мы можем перейти от мамы к папе.
> virtual метод - это такой метод, что решение выбора версии метода принимается в runtime, а не в compile-time.

## $ 5.5 Memory layout of polymorphic objects.
В этой главе углубимся в компилятор и посмотрим приблизительно как все это работает (ABI).

```
struct Base {
    virtual void f() {}
};
```
Какой размер у этой структуры?  
Ответ: `sizeof(Base) => 8`  
Это обусловлено тем, что виртуальные методы хранят указатель на таблицу виртуальных функций (vtable). Раннее уже встречались с этой таблицей.
В этой таблице хранятся как адреса виртуальных предков так и адреса виртуальных методов (виртауальных предков обсудим в след. параграфе).

Рассмотрим подробно внутренность `vtable`:
```
+-------------+
|type_info obj| - хранит объект с названием типа Base
+-------------+
        ^
        |         +---+
        |         |ptr| - указатель на vtable
        |         +---+
        |           |
        |           \/
+----------------+---------+--------..............--------+
|& std::type_info|& Base::f|адреса остальных вирт. функций|
+----------------+---------+-------...............--------+
  ^                 ^
  |                 |
  адрес объекта    адрес вирт.
  type_info        метода
```
Добавим разнообразия в нашу структуру:
```
struct Base {
    virtual void f() {}
    void h() {}
    int x = 0;
};
```
Теперь наше представление в памяти будет выглядить вот так:
```
+-------------+
|type_info obj| 
+-------------+
        ^
        |         +---+-+------------+
        |         |ptr|x|padding4byte| - структура Base
        |         +---+-+------------+
        |           |
        |           \/
+----------------+---------+--------..............--------+
|& std::type_info|& Base::f|адреса остальных вирт. функций|
+----------------+---------+-------...............--------+
```
Создадим стркутуру наследника:
```
struct Base {
    virtual void f() {}
    void h() {}
    int x = 0;
};

struct Derived: Base {
    void f() override {}
    virtual void g() {}
    int y;
};
```
Представление в памяти `Derived`:
```
+-------------+
|type_info obj| - хранит объект с названием типа Base
+-------------+
        ^
        |         +---+-+-+
        |         |ptr|x|y|
        |         +---+-+-+
        |           |
        |           \/
+----------------+------------+------------+---
|& std::type_info|& Derived::f|& Derived::g|....
+----------------+------------+------------+---
```

Что происходило когда мы запускали:
```
Base b;
b.f();
```
1. Идем в runtime в `vtable` по ptr с которого начинается объект.
2. Компилятор понимает, что f() первая виртуальная функция, извлекаем первые 8 байт(разыменовываем указатель) и получаем нужную функцию.

При таком коде:
```
Base b;
Derived& d = b;
d.f();
```
Все те же действия, но идем в таблицу `vtable` для `Derived`.

А что же там с бабушкой?
```
struct Granny {
    int g;
    void h() {}
};

struct Mom: Granny {
    int m;
    virtual void f() {}
};

struct Son: Mom {
    int s;
    void f() override {}
};
```
Объект `Son` в памяти:
```
Son
|    Granny
|    |
+---+-+-+-+
|ptr|g|m|s|
+---+-+-+-+
```
`dynamic_cast` от `Son` к `Granny` сработает. А в обратную сторону уже работать не будет. Так как указатель на начало `Son` будет сдвинут на начало `Granny`. И наш исходный тип уже будет не полиморфным.
`static_cast` доолжен уметь работать в обе стороны.

## $ 5.6 Memomry layout of polymorphic  objects

with multiple inheritance

Рассмотрим случай с не виртуальным наследованием

    Grenny  Grenny
       ^      ^
	   |      |
      Mom    Ded
	    \   /
	     Son
```
struct Grenny {
    virtual void f();
    int g;
};

struct Mom: Grenny {
    int m;
};

struct Ded: Grenny {
    int d;
};

struct Son: Mom, Ded {
    int s;
};
```
Объект Son в памяти будет выглядеть так?
```
+---+-+-+-+-+-+--
|ptr|g|m|g|d|s|...
+---+-+-+-+-+-+--
```
На самом деле нет, полиморфные классы еще хранят указатель на `vtable`.
Адрес начала Son и Mom совпадает поэтому для них один и тот же `ptr` в начале объекта. А в нашей схеме нет `ptr` для `Ded`, добавим его.
```
+---+-+-+---+-+-+-+--
|ptr|g|m|ptr|g|d|s|...
+---+-+-+---+-+-+-+--
```
Теперь все правильно.

Добавим переопределение метода `f()` в классе `Son`
```
struct Grenny {
    virtual void f();
    int g;
};

struct Mom: Grenny {
    int m;
};

struct Ded: Grenny {
    int d;
};

struct Son: Mom, Ded {
    void f() override {}
    int s;
};
```

`vtable` тоже имеет некоторые изменения. Мы уже говорили о том, что в виртуальной таблице должен храниться top_offset. Это число которое хранит наш сдвиг от начала объекта. Это полезно при использовании `dynamic_cast`. Например, если мы пытаемся привести `Ded` к `Mom`, то именно `top_offset` поможет определить правильный адрес `Mom` в памяти.

> Non-virtual thunk - спец. вспомогательный метод, который компилятор генерирует для обеспечения правильного отступа к виртуальным функциям. Он необходим когда происходит вызов виртуальной функции через указатель на базовый класс, но сам объект является экземпляром производного класса.

Как работает `non-virtua thunk`:
1. Сдвигается на `top_offset`: `this -= top_offset`;
2. Вызывает нужый нам метод: `call method_name`.

Давайте напишем `vtable` для такого случая:

```
Son s;
Ded& d = s;
d.f();
```
Ded-in-Son vtable:
```
+----------+----------+-------+--
|top_offset|& typeinfo|& thunk|...
+----------+----------+-------+--
			  |
                          \/
	      +------------------+
              |this -= top_offset|
	      +------------------+
              |   call Son::f()  |
	      +------------------+
```
 Теперь посмотрим на это все с виртуальным наследованием.
```
struct Grenny {
    virtual void f();
    int g;
};

struct Mom: virtual Grenny {
    int m;
};

struct Ded: virtual Grenny {
    int d;
};

struct Son: Mom, Ded {
    void f() override {}
    int s;
};
```
Кроме `top_offset` в `vtable` появляется и `virtual_offset`. Т.е. в каждом таблице должно быть написано на сколько мы далеко от начала объекта и еще на сколько далеко от нас начало виртуального предка.

Как выглядит `Son` теперь:
```
+---+-+---+---+-+-+---+-+--
|ptr|m|...|ptr|d|s|ptr|g|...
+---+-+---+---+-+-+---+-+--

... - это padding(выравнивание)
```
Все `vtable`:
```
Son:
+--------------+----------+--------+--------+        +---+
|virtual_offset|top_offset|& Son   |& Son::f| -----> |f()| <---------+
|       32     |    16    |typeinfo|        |        +---+           |
+--------------+----------+--------+--------+                        |
                                                                     |
Ded in Son:                                                          |
+--------------+----------+--------+-----------+      +----------+   |
|virtual_offset|top_offset|& Son   |& Ded::f() | ---> |this -= 16|   |
|      16      |    16    |typeinfo|   thunk   |      +----------+   |
+--------------+----------+--------+-----------+      |& Son::f()|---+
                                                      +----------+   |
                                                                     |
Grenny (у нее нет виртуальных предков):                              |
+----------+--------+-------------+      +----------+                |
|top_offset|& Son   |& Granny::f()| ---> |this -= 16|                |
|    32    |typeinfo|    thunk    |      +----------+                |
+----------+--------+-------------+      |& Son::f()| ---------------+
                                         +----------+
```
На самом деле таблиц еще очень много. Почитай, если интересно :)
Подробные статьи про устройство `vtable` есть в блоге у shaharmike

## $ 5.7 Non obvious problems with virtual functions.
```
struct Base {
  int x;
  static virtual void f() {}
};

struct Derived: Base {
};

int main() {
  Derived d;
}
```
1. Можем ли сделать виртуальную функцию статической?
Ответ: Нет, будет CE.

```
struct Base {
  int x;
  virtual void f() {}
};

struct Derived: Base {
};

int main() {
  Derived d;
}
```
2. Виртуальные функции нельзя оставлять без определения, если это не pure virtual функции.
В нашем примере будет ошибка линкера.

```
struct Base {
  virtual void h() = 0;
  void f() {
    std::cout << "f";
  }
  Base() {
    std::cout << "Base";
    h();
  }
  virtual ~Base() = default;
};

struct Derived: Base {
   int x;
   void h() override {
     std::cout << "h" << x;
   }
   Derived(): x(0) {
     std::cout << "Derived";
   }
};

int main() {
  Derived d;
}
```
3. Будет ошибка линкера.
Если мы из конструктора или из списка инициализаций вызывает виртуальную функцию, то механизм виртуальных функций отключается. Когда мы вызываем виртуальную функцию из конструктора она считается обычной во избежание `UB`.
Из-за того что фукция h() pure virtual, линкер просто не находит ее определение. Будь функция h() с определением, все было бы ОК.

```
struct Base {
  virtual void h() = 0;
  void f() {
    std::cout << "f";
    h();
  }
  Base() {
    std::cout << "Base";
    f(); // ???
  }
  virtual ~Base() = default;
};

struct Derived: Base {
   int x;
   void g() {
     f();
   }
   void h() override {
     std::cout << "h" << x;
   }
   Derived(): x(0) {
     std::cout << "Derived";
   }
};

int main() {
  Derived d;
}
```
4. Будет `RE` c ошибкой `pure virtual method called`.
На самом деле в `vtable` класса `Base` по адресу по которому должна лежать `f()` лежит указатель на спец. место где лежит заглушка. Заглушка выводит сообщение `pure virtual method called` и вызывает terminate. То же самое `RE` произойдет при вызове  `f()` из деструктора.
Из этого примера понимаем, что в процессе конструирования объекта виртуальная таблица изменяется. Когда создается полиморфный объект сначала создается родительский объект и первый делом указатель на `vtable` инициализируется таблицей на родителя. Потом инициализируются поля родителя и конструктор родителя.
Уже после этого указатель на `vtable` переставляется на `vtable` класса наследника, инициализируются поля наследника и конструктор.
Отдельно кроме всего добра должна существовать таблица Mom внутри Son, Ded внутри Son. Если я сейчас мама и конструируюсь у меня должен быть отдельно указатель для мамы внутри сына. То же самое для папы но со смещением.
Отдельно есть `table vtable` в котором как раз таки хранятся в правильном порядке эти указатели.
При удалении объекта все в обратном порядке.

```
struct Base {
  virtual void f(int x = 1) {
    std::cout << "Base" << x;
  }
};

struct Derived: Base {
  virtual void f(int x = 2) {
    std::cout << "Derived" << x;
  }
};

int main() {
  Derived d;
  Base& b = d;
  b.f();
}
```
5. Здесь выведется `Derived1`.
Аргумент по умолчанию подставляется в `complie-time`. Поэтому `x` присваивается 1.
А в `runtime` компилятор попадает в `f()` из `Deridved`.


```
struct Mother {
  int x = 0;
  virtual void f() {
    std::cout << x;
  }
};

struct Father {
  int y = 1;
  virtual void g() {
    std::cout << y;
  }
};

struct Son: Mother, Father {
  int z = 2;
  virtual void f() override {
    std::cout << z;
  }
  virtual void g() override {
    std::cout << z;
  }
};

struct S {
  long long a;
  long long b;
};

// При таком мейне результат будет:
// 2
// 16 1 0

int main() {
  void (Mother::*p)() = &Mother::f;

  Son son;
  Mother& m = son;
  (m.*p)();

  std::cout << sizeof(p) << ' ';
  S s = reinterpret_cast<S&>(p);
  std::cout << s.a << ' ' << s.b << '\n';
}

// При таком мейне результат будет:
// 2
// 16 1 16

int main() {
  void (Son::*p)() = &Father::g;
  Son son;
  (son.*p)();

  std::cout << sizeof(p) << ' ';
  S s = reinterpret_cast<S&>(p);
  std::cout << s.a << ' ' << s.b << '\n';
}

// При таком мейне результат будет:
// 2
// 16 9 0

int main() {
  void (Son::*p)() = &Son::g;
  Son son;
  (son.*p)();

  std::cout << sizeof(p) << ' ';
  S s = reinterpret_cast<S&>(p);
  std::cout << s.a << ' ' << s.b << '\n';
}
```
6. Метод под указателем на виртуальный метод будет все так же вести себя как виртуальный.

Первое число - показывается сдвиг относительно виртуальной таблицы.
Второе число - показывает сдвиг относительно начала объекта.
В первых 8 байтах хранятся адреса. А чтобы отличать виртуальные указатели в послений бит ставится 1.

