# VII. Exceptions.

## $ 7.1. Idea of exceptions, basic examples.

Старые подходы к обработке ошибок:
1. Возврат любого код ошибки из функции.
2. Передаче объекта для хранения кода ошибки через указатель в параметры функции.
Вот, например, `malloc` - он возвращает `NULL` при ошибке выделения памяти, а дальше обработка этого случая уже лежит на программисте, который использует эту функцию.

Что же придумал создатель С++?
Когда у вас есть функция, которая может завершиться неудачно, он не будет возвращать код ошибки, а будет кидать вверх исключение.  

Чтобы выкинуть исключение используется конструкция:`throw exception_object`.  
Обычно кидают уже готовые объекты исключений. Они прописаны в `<exception>.`
Пример, обработаем деление на нуль:
```
int divide(int a, int b) {
  if (b == 0) {
    throw std::logic_error("Devide by zero");
  }
  return a/b;
}

int main() {
  divide(1, 0);
}
```

Что же происходит при исключениии?
Допустим мы зашли в 10 функций примерно и оказались на 10 уровне стека. Когда кидается исключение уничтожаются все локальные переменные этой функции и мы выходим на уровень выше, в уровень 9 и так далее пока все не уничтожется.  
Но как нам поймать и обработать эту ошибку?
Для этого используется конструкция:
```
try {
  // код в котором возникло исключение
} catch(/* exception_object*/) {
  // что делать если исключение поймано
}
```
И у стандартных объектов есть методы для обработки исключений, одна из полезнейших это вывод информации о том что же случилось : `what()`.  
Поймаем деление на нуль:
```
int main() {
  try {
    divide(1, 0);
  } catch(std::logic_error& err) {
    std::cout << err.what();
  }
}
```
Вместо `exception_object` можно написать `...`, что упрощает ловлю ошибок.

`try catch` очень дорогая операция, даже дороже чем `new`, `delete`.

Какие стандартные операторы бросают исключения?
1. `new` - кидает исключениие `std::bad_alloc`, если не получилось выделить память. 
Зачастую при непойманном исключении вызывается функция `std::terminate`(о других случаях ее вызова написано в `cppreference`). А `std::terminate` печатает сообщение об ошибке и вызывает функцию `abort` которая говорит ОС убить нашу программу.
2. `dynamic_cast` - кидает исключение `std::bad_cast`
3. `typeid`
4. `throw`

## $ 7.2 Difference between exceptions and runtime errors.

Нужно понимать границы того что является исключением, а что - нет. Не исключения поймать невозможно.
Примеры не исключений:
```
int main() {
  std::vector<int> v;
  try {
    v[10000000] = 1;
  } catch(...) {
    std::cout << "Caught!";
  }
}
```
Будем `segmentation fault`. Но это не исключение.

```
int main() {
  int x;
  std::cin >> x;
  try {
    int y = 5/x; // при x = 0 будет деление на ноль
  } catch(...) {
    std::cout << "Caught!";
  }
}
```
Будет `Floating point exception`. И он тоже не поймается так как это исключение уровня процессора. Это не исключение уровня С++.
> Пойманы могут быть исключения уровня С++, а исключения уровня ОС поймать невозможно. В свою очередь исключения уровня С++ могут вызывать исключения уровня ОС, например: `abort`.

Исключения подразделяются на два подвида: `logic_error` и `runtime_error`.
`logic_error` - ошибка в котором виноват пользователь.
`runtime_error` - пользователь все сделал нормально, но случилась не предвиденная ситуация. Например, передал в функцию сложения два числа а там `overflow` случился.  
Полная иерархия исключений: https://en.cppreference.com/w/cpp/error/exception

Картина мира исключений:
```
            +-----------+
            |  nullptr  |
            |dereference|
            +-----------+
+---------+       |       +--------+
|array out|       |       | stack  |
|of bounds|       |       |overflow|
+---------+       |       +--------+
     \            |            /
      \           |           /
       \          |          /
        \         |         /
         \        |        /
-----------+-------------+----------------
           |segmentation |
           |   fault     |
           +-------------+
```
```
             +--------+
             |division|
             |by zero |
             +--------+
                 |
                 |
----------+--------------+----------------
          |floating point|
          |exception(FPE)|
          +--------------+
```
```
+--------------+   +----------+
|pure virtual  |   |uncaught  |
|function call |   |exceptions| 
+--------------+   +----------+
      \                  /
       \                /
        +--------------+        +---------+
        |std::terminate|        |  false  | 
        +--------------+        |assertion|
                |               +---------+
                |                 /
                |                / 
                |               /
           +----------+        /
           |std::abort|-------+
           +----------+
                |
                |
                |
------------+--------+---------------------
            |Aborted |
            +--------+
```
## $ 7.3 Exceptions handling
Рассмотрим что происходит с объектами исключений.
```
struct A {
  A() { std::cout << "A" << std::endl; }
  A(const A&) {std::cout << "Copy" << std::endl; }
  ~A() {std::cout << "~A" << std::endl; }
};

// просто функция выбрасывающее исключение.
void f(int x) {
  A a;
  if (x == 0) {
    throw a;
  }
}

int main() {
  try {
    f(0);
  } catch(...) {
    std::cout << "caught!";
  }
}
```
Исключение бросает объект `a`, но где он его в это время хранит? Хранит он ее в динамической памяти.
0. В функции `f` создается объект `a`.
1. Когда мы бросаем объект компилятор его как раз таки копирует в эту зарезервированную динамическую память.
2. Объект `a` из функции `f` будет уничтожен.
3. Попадаем в `catch` и при выходе из него объект `a` из динамичесой памяти уничтожается.
Вывод нашей программы:
```
A
Copy
~A
caught!
~A
```

Но мы сейчас ловили через `...`, что будет если напишем вот так:
```
int main() {
  try {
    f(0);
  } catch(A a) {
    std::cout << "caught!";
  }
}
```
В таком случае, при входе в `catch` у нас произойдет еще оно копирование: объекта `a` из динамической памяти будет положен на стек в объект `a` из блока `catch`. Добавим отладочного вывода и посмотрим результат:
```
void f(int x) {
  A a;
  std::cout << &a << std::endl;
  if (x == 0) {
    throw a;
  }
}

int main() {
  try {
    f(0);
  } catch(A a) {
    std::cout << &a << std::endl;
    std::cout << "caught!";
  }
}
```
Вывод программы:
```
A
0x7ffda6fae8af
Copy
~A
Copy
0x7ffda6fae8ef
caught!
~A
~A
```
Как мы видим адреса у объектов разные. И больше похожи на адреса стека.

Если будем ловить по ссылке, то лишнего копирования не будет:
```
int main() {
  try {
    f(0);
  } catch(A& a) {
    std::cout << &a << std::endl;
    std::cout << "caught!";
  }
}
```
Вывод программы:
```
A
0x7ffd9b493b5f
Copy
~A
0x55ccd210d340
caught!
~A
```
Как видно последний адрес уже отличается и он скорее всего принадлежит динамической памяти.

А что если у нас будет проблема с работой оператора `new`, которая кидает объект `std::bad_alloc`. 
```
int main() {
  try {
    new int[400'000'000'000];
  } catch(A& a) {
    std::cout << "caught!";
  } catch(std::bad_alloc& ex) {
     std::cout << &ex << std::endl;
  }
}
```
Где хранить этот объект, если выделение динамической памяти не работает? Компилятор зарезервирует память на стеке для объекта `std::bad_alloc`.

В `catch` мы можем снова кинуть исключение: `throw a`. Это снова создаст объект `a` и кинет его. Но мы можем передавать выше уже существующий объект исключения, просто написав `throw;` без параметров. Обратите внимание, что это уже исключение уровня выше и `catch` на этом уровне не поймают это исключение.
```
int main() {
  try {
    try {
      new int[400'000'000'000];
    } catch(A& a) {
      std::cout << "caught!";
      throw; // передаем выше существующий объект `a`
    } catch(A& a) { // не поймает снова кинутое исключение
      // ... 
    }
  } catch(A& a) { // поймает исключение
     std::cout << "caught again!";
  }
}
```

> Если исключение не ловится, то нет никаких гарантий компилятором вызова  конструктора, деструктора.
Просто вызов `f(0);` без ловли исключения, покажет что деструктор не вызвался:
```
int main() {
  f(0);
}
```

### Multiple catch
По правилам перегрузки в С++ обычно берется вариант, который лучше всего подходит(не надо конвертировать, меньше проблем при конвертации и т.д.). Но в `catch` конверсия из одного типа в другой запрещена с некоторыми исключениями:
1. Конверсия к `const`
2. Конверсия к ссылке на родителя при наследовании
Пример:
```
struct Mom {};
struct Son: Mom {};

int main() {
  try {
    Son s;
    throw s;
  } catch(Mom) {
    std::cout << "caught Mom";
  }
}
```
Мы попадем в `catch(Mom)`. Есть некоторая проблема. В таком случае мы никогда не попадем к сыну, нас всегда будет перехватывать `catch(Mom)`:
```
struct Mom {};
struct Son: Mom {};

int main() {
  try {
    Son s;
    throw s;
  } catch(Mom) {
    std::cout << "caught Mom";
  } catch(Son) {
    std::cout << "caught Son";
  }
}
```
Сделаем наследование от `Mom` приватым, тогда `main` будет считать `Mom` недоступным для себя и мы будем попадать в `catch(Son)`.
```
struct Mom {};
struct Son: private Mom {};

int main() {
  try {
    Son s;
    throw s;
  } catch(Mom) {
    std::cout << "caught Mom";
  } catch(Son) {
    std::cout << "caught Son";
  }
}
```
А что же будет при ромбовидном наследовании? Из-за того что у нас два экземпляра `Granny` в `Son`, компилятор выберет `catch(Son)`:
```
struct Granny {};
struct Ded: Granny {};
struct Mom: Granny {};
struct Son: Ded, Mom {};

int main() {
  try {
    Son s;
    throw s;
  } catch(Granny) {
    std::cout << "caught Mom";
  } catch(Son) {
    std::cout << "caught Son";
  }
}
```
Исправим ромбовидное наследование и будем попадать в `catch(Granny)`:
```
struct Granny {};
struct Ded: virtual Granny {};
struct Mom: virtual Granny {};
struct Son: Ded, Mom {};

int main() {
  try {
    Son s;
    throw s;
  } catch(Granny) {
    std::cout << "caught Mom";
  } catch(Son) {
    std::cout << "caught Son";
  }
}
```

## $ 7.4 RAII(Resource Acquisition Is Initialization) 

"Приобретение ресурса есть инициализация"

Как уже говорилось исключения уничтожают объекты и выходят на уровень выше. Но что если мы динамически выделяем память и сами же ее чистим. Но перед очисткой у нас выбросилось исключение. Это приводит к утечке памяти.  
```
void g(int y) {
  if (y == 0) {
    throw 1;
  }
}

void f(int x) {
  int* p = new int(x);
  g(*p);
  delete p;
}
```

Эту проблему можно решать двумя способами:
1. Оборачивать все промежуточные функции в `try-catch`. Но это приведет к миллиону ненужных ветвлений, а исключения нужны были как раз для избавления от них.
2. Использовать ООП. Создадим обертку, которая в конструкторе выделит память, а в деструкторе очистит ее. И нам не надо переживать на счет очистки памяти. Когда кинется исключение наша локальная обертка уничтожится(вызовется ее деструктор):
```
struct Wrapper {
  int* p;
  Wrapper(int *p): p(p) {}
  ~Wrapper() { delete p; }
};

void g(int y) {
  if (y == 0) {
    throw 1;
  }
}

void f(int x) {
  Wrapper w(new int(x));
  g(*(w.p));
}
```
На самом деле мы с вами написали умный указатель.
> умный указатель - обертка над указателями который сам очищает память, если это необходимо.
У умных указателей так же доступна операция разыменования:
```
struct SmartPtr {
  int* p;
  SmartPtr(int *p): p(p) {}
  ~SmartPtr() { delete p; }
  int& operator*() {
    return *p;
  }
};
```
На данный момент у нас разрешено копирование и из-за этого может быть два и более вызова деструктора. Это плохо, поэтому следует запретить констрктор копирования и оператор присваивания:
```
struct SmartPtr {
  int* p;
  SmartPtr(int *p): p(p) {}
  SmartPtr(const SmartPtr&) = delete;
  SmartPtr& operator=(const SmartPtr&) = delete;
  ~SmartPtr() { delete p; }
  int& operator*() {
    return *p;
  }
};
```
И под конец сделаем его шаблонным, чтобы он мог создавать не только от `int`:
```
template <typename T>
struct SmartPtr {
  T* p;
  SmartPtr(T *p): p(p) {}
  SmartPtr(const SmartPtr&) = delete;
  SmartPtr& operator=(const SmartPtr&) = delete;
  ~SmartPtr() { delete p; }
  T& operator*() {
    return *p;
  }
};
```
На самом деле то что мы написали реализована в стандартной библиотеке и называется он `unique_ptr`.

## $ 7.5 Exceptions in constructors.
Рассмотрим случай выброса исключения в конструкторе:
```
struct A {
  A() { std::cout << "A"; }
  ~A() { std::cout << "~A"; }
};

struct S {
  A a;
  S (int x) {
    std::cout << "S";
    if (x == 0) throw 1;
  }
  ~S() {
    std:: cout << "~S";
  }
};

int main() {
  try {
    S s(0);
  } catch (...) {
    // ... 
  }
}
```
Из-за выброса исключени в конструкторе класса `S` объект `s` будет считаться не созданным и деструктор у него не вызовется. А объект `a` уничтожится перед выходом.

Теперь представим ситуацию, если у нас есть в структуре три дополнительных объекта `A` и они создаются в списке инициализации структуры `S`.
```
struct A {
  A() { 
    std::cout << "A"; 
    if (x == 0) throw 1;
  }
  ~A() { std::cout << "~A"; }
};

struct S {
  A a;
  A aa;
  A aaa;
  S (int x): a(1), aa(0), aaa(2) {
    std::cout << "S";
  }
  ~S() {
    std:: cout << "~S";
  }
};

int main() {
  try {
    S s(0);
  } catch (...) {
    // ... 
  }
}
```
В таком случае создастся объекты до создания объекта, выбрасывающего исключение. И эти объекты уничтожатся. В нашем примере это только объект `a`.

Но есть ли способ ловить исключение напрямую из списки инициализации?  
Да, и эта конструкция называется `function-try block`.
```
struct A {
  A() { 
    std::cout << "A"; 
    if (x == 0) throw 1;
  }
  ~A() { std::cout << "~A"; }
};

struct S {
  A a;
  A aa;
  A aaa;
  S(int x) try: a(1), aa(0), aaa(2) {
    std::cout << "S";
  } catch (...) {
    std::cout << "Caught!";
  }
  
  ~S() {
    std:: cout << "~S";
  }
};

int main() {
  S s(0);
}
```
Эту же конструкцию можно использовать и для функций:
```
void f() try {
  // ...
} cathc (...) {
  // ...
}
```
А что произошло с объектом `s` из `main`.
На самом деле при использовании `function-try block` у нас неявно вызывается `throw`. И до использования объекта `s` дело не дойдет. 
Можно в `catch` у `function-try block` сделать `return` за счет чего исключение новое не будет выброшено. Но стандартом запрещено писать `return`.
Прежде чем вы входите в `catch` в `function-try block`-е все сконструированные члены и родители уже уничтожены к этому моменту.
Подробно можно посмотреть на сайте:
https://en.cppreference.com/w/cpp/language/function-try-block

### Exceptions in destructor.
Бросать исключения из деструктора запрещено начиная с С++11, при таком случае будет вызван `std::terminate` даже если вы попытаетесь поймать исключение.
```
struct A {
  A(int) {
    std::cout < "A";
  }

  ~A() {
    std::cout << "~A";
    throw 1;
  }
};
int main() {
  try {
    A a(0);
  } catch (...) {
    // ...
  }
}
```
Но можно написать волшебную конструкцию, которая разрешит бросать исключение из деструктора - `noexcept(false)`.
```
struct A {
  A(int) {
    std::cout < "A";
  }

  ~A() noexcept(false) {
    std::cout << "~A";
    throw 1;
  }
};
```

Бывает случай когда и эта конструкция не поможет. Этот случай происходит при вызове исключения. А исключение как мы знаем уничтожает объекты перед выходом: вызовется уничтожение объекта `a` деструктор которого вызывает исключение. За счет чего все равно будет `std::terminate`. 
```
struct A {
  A(int) {
    std::cout < "A";
  }

  ~A() noexcept(false) {
    std::cout << "~A";
    throw 1;
  }
};
int main() {
  try {
    A a(0);
    throw 1; // выброс ислючения, приводящиий к уничтожению объектов
  } catch (...) {
    // ...
  }
}
```
В С++11 появилась функция, которая может проверить выброшено ли на данный момент еще какое-то исключение: `std::uncaught_exception`.
Пример работы с ним:
```
struct A {
  A(int) {
    std::cout < "A";
  }

  ~A() noexcept(false) {
    std::cout << "~A";
    if (!std::uncaught_exception()) {
      throw 1;
    }
  }
};
```
Но к С++17 поняли, что исключений может быть на данный момент времени выброшено сколько угодно и на замену `std::uncaught_exception` пришел `std::uncaught_exceptions` - смотрит наличие нескольких ислючений. А в С++20 `std::uncaught_exception` была полностью удалена.

## $ 7.6 Exception safety.

Код, в котором выброшено исключение, продолжает работать корректно работать называется безопасным относительно исключений.

Бывает 4 уровня безопасности относительно исключений:
1. `Nothrow` - исключений вообще нет.
2. `Strong exception guarantee` - при выбросе исключения функция возвращает все так как было до исключения. Например, `std::vector::push_back()`, отмениит добавление элемента в `std::vector`, удалит все что скопировал  и вернет размер `std::vector` до размера перед добавлением элемента. Вообще стандартные контейнеры работают с такой гарантией относительно исключений.
3. `Base exception guarantee` - при исключении объекты остаются в валидном состоянии, нет утечек памяти. 
4. `No exception guarantee` - при исключениях может быть все что угодно `UB`.

### Ключевое слово noexcept.

В С++11 появилось ключевое слово `noexcept` которая говорит о том что мы не будем бросать исключение из нашей функции и при вызове нашей функции все будет хорошо.
Но если мы все же бросим исключение из функции, то будет `std::terminate`.
```
void f() noexcept {
}
```
До С++11 можно было писать лютые штуки используя `throw` и перечислив список типов которые можно бросать. Писалась эта конструкция там где пишется `npexcept`.  
Бывает еще условный `noexcept`. Например, если имеется шаблонна функция и мы хотим при каких-то типах `T` сказать что функция `noexcept`.
```
template <typename T>
void f() noexcept(std::is_reference_v<T> {
}
```
Существует оператор `noexcept()` - он проверяет является ли переданное в арргументы выражение `noexcept` или нет. Просто смотрит помечена ли функция `noexcept`. А что касается стандартных операторов, из них почти все являются `noexcept` кроме: `new`, `dynamic_cast`, `typeid`, `throw`.
Благодаря этому оператору мы можем помечать нашу функцию `noexcept` если какая-то другая функция тоже `noexcept`. Наглядным примером является конструктор `std::vector`, который является `noexcept`, если конструктор аллокатора тоже `noexcept`:
```C++
tempalte <typename T>
void g() {
  // ...
}

templatet <typename T>
void f() noexcept(noexcept(g<T>()) {
  // ...
}
```
В `std::vector`:
```
vector() noexcept(noexcept(Allocator()));
```
Кстати, если взглянуть на `operator[]` в `std::vector`, то мы видим что он не помечен как `noexcept`. Это потому что  `noexcept` помечаются еще функции которые точно корректно отработают. Видимо `operator[]` не такой :).
По умолчанию с С++11 все деструкторы по умолчанию `noexcept`.

