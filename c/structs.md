# Структурры

<details>
<summary>
  Выравниваение данных в структурах
</summary>

Вопросов по данной теме можно придумать кучу:

1. Сколько памяти используется для структуры с одним полем типа int и вторым полем типа char.
2. Сколько памяти используется для структуры с одним полем типа int и пятью полями типа char.
И т.д.

Зависит от архитектуры! Для начала прочитай: [это]()

Размер структуры как и обычного типа можно узнать используя `sizeof()`.

```c
struct S {
  int i;
};

// Sizeof S: 4
printf("Sizeof S: %ul\n", sizeof(struct S));
```

Размер структур сильно зависит от `выравнивания данных` `(data alignment)`.

Компилятор обычно выравнивает данные в памяти по границам, кратным размеру типа данных (например, 4 байта для `int`, 1 байт для `char`). Выравнивание осуществляется по самому строгому требованию (наибольшему типу) среди всех элементов структуры.

Это оптимизация для повышения производительности доступа к памяти. Например, если создать массив из структур, то без выравнивания некоторые элементы структуры могли бы оказаться по невыровненным адресам, что привело бы к значительному снижению производительности или даже к ошибкам при использовании `[]` для доступа к элементам.

Требования выравнивая типа можно узнать использую функцию `alignof()`.

```c
struct S {
  int i;
  char c;
}

// Alignof S: 4
printf("Alignof S: %ul\n", alignof(struct S));
```

В примере мы можем видеть как происходит выравнивание в зависимости от объявления  членов структуры (выравнивание происходит по `int`):

```c
struct P1 {
  char c1; // 1 byte
  int n1;  // 4
  char c2; // 1
  char c3; // 1
  int n2;  // 4
};

sizeof(struct P1) -> 16
alignof(struct P1) -> 4

Представим как табличку байтов:
|0 [1 2 3] | 4 5 6 7 | 8 9 [10 11] | 12 13 14 15

Байты в квадратных скобках - это байты для выравнивания (padding).

struct P2 {
  int n1;  // 4
  char c1; // 1 byte
  char c2; // 1
  char c3; // 1
  int n2;  // 4
};

sizeof(struct P2) -> 12
alignof(struct P2) -> 4

Представим как табличку:
0 1 2 3 | 4 5 6 [7] | 8 9 10 11
```

Можно подробно посмотреть по какому смещению находится поле в структуре. Функция `offsetof(type, member)` принимает тип структуры и имя поля этой структуры, смещение которого мы хотим посмотреть. Для нашего первого примера:

```c
struct P1 {
  char c1; // 1 byte
  int n1;  // 4
  char c2; // 1
  char c3; // 1
  int n2;  // 4
};

printf("Offset of c1: %lu\n", offsetof(struct P1, c1)); // 0
printf("Offset of n1: %lu\n", offsetof(struct P1, n1)); // 4
printf("Offset of c2: %lu\n", offsetof(struct P1, c2)); // 8
printf("Offset of c3: %lu\n", offsetof(struct P1, c3)); // 9
printf("Offset of n2: %lu\n", offsetof(struct P1, n2)); // 12
```

</details>

<details>
<summary>
  Упаковка структур
</summary>

Для оптимизации потребления памяти мы можем упаковать структуры, убрав выравнивания. С примера выше возьмем структуру:

```c
struct P1 {
  char c1; // 1 byte
  int n1;  // 4
  char c2; // 1
  char c3; // 1
  int n2;  // 4
};

sizeof(struct P1);  // -> 16
alignof(struct P1); //  -> 4
```

Как можно оптимизировать использование памяти? Просто переставим два поля

```c
struct P1 {
  int n1;  // 4
  char c1; // 1
  char c2; // 1
  char c3; // 1
  int n2;  // 4
};

sizeof(struct P1);  // -> 12
alignof(struct P1); //  -> 4
```

Теперь используется всего один байт выравнивания и структура стала занимать меньше памяти.

Мы можем избавиться полностью от выравнивания, для этого в С есть директива `#pramga pack`. Перед структурой необходимо выполнить `#pragma pack(push, 1)` и после структуры `#pragma pack(pop)`. Первая команда сохраняет текущее выравнивание в стек и устанавливаем новое равным 1, а второй командой мы восстанавливаем предыдущее выравнивание из стека. Пример:

```c
#pragma pack(push, 1)
struct P1 {
  int n1;  // 4
  char c1; // 1
  char c2; // 1
  char c3; // 1
  int n2;  // 4
};
#pragma pack(pop)

sizeof(struct P1);  // -> 11
alignof(struct P1); // -> 1
```

И это сработало, теперь наша структура весит еще на 1 байт меньше :).

</details>
