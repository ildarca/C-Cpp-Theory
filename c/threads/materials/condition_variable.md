# Семафоры и мьютексы

Мьютексы должны быть заблокированы и разблокированы одним потоком.

Получение значений семафора. Значение семафора все равно может быть поодвержено гонке данных. Потому что между моментом чтения и моментом использования этого значения другие потоки могут изменить состояние семафора.

## Условные переменные (Condition variables)

Напишем программу, в которой будет машина и заправка. За заправку будет отвечать функция `void *fuel_filling(void *arg)`, а за машину `void *car(void *arg)`. Для каждой из этих функций будет свой собственный поток (пока будем думать что у нас только одна заправка и одна машина т.е. два потока).

```c
#define THREAD_COUNT 2

thread_t th[2];
for (int i = 0; i < THREAD_COUNT; i++) {
  if (i == 1) {
    if (pthread_create(&th[i], NULL, fuel_filling, NULL) != 0) {
      perror("Failed to create thread");
    }
  } else {
    if (pthread_create(&th[i], NULL, car, NULL) != 0) {
      perror("Failed to create thread");
    }
  }
}
```

И не забываем ждать окончания потоков:

```c
for (int i = 0; i < THREAD_COUNT; i++) {
  if (pthread_join(th[i], NULL) != 0) {
    perror("Failed to join thread");
  }
}
```

Заведем общую переменную, которая будет отвечать за уровень бензина `int fuel = 0;`. Так как она общая для двух потоков, добавим сюда еще и мьютекс:

```c
pthread_mutex_t mutexFuel;
int fuel = 0;

pthread_t th[2];
pthread_mutex_init(&mutexFuel, NULL);
// код создания потоков
// код ожидания завершения потоков
pthread_mutex_destroy(&mutexFuel);
```

Определим функционал для заправки и машины. Пусть заправка добавляет по 15 литров бензина за раз и делает это постепеноо 5 раз, при каждом добавлении выводит на экран сколько топлива на данный момент. Не забывает блокировать мьютекс во время использования `fuel`.

```c
void *fuel_filling(void *arg) {
for (int i = 0; i < 5; i++) {
  pthread_mutex_lock(&mutexFuel);
  fuel += 15;
  printf("Добавлено топливо. Сейчас: %d\n", fuel);
  pthread_mutex_unlock(&mutexFuel);
  sleep(1);
}
}
```

А машина пусть тратит 40 литров за раз и печатает сколько осталоось топлива

```c
void *car(void *arg) {
pthread_mutex_lock(&mutexFuel);
fuel -= 40;
printf("Осталось топлива: %d\n", fuel);
pthread_mutex_unlock(&mutexFuel);
}
```

При запуске программы мы получим следующий результат:

```text
Осталось топлива: -40
Добавлено топливо. Сейчас: -25
Добавлено топливо. Сейчас: -10
Добавлено топливо. Сейчас: 5
Добавлено топливо. Сейчас: 20
Добавлено топливо. Сейчас: 35
```

У нас топливо получилось отрицательным, хотелось бы чтобы был какой-то нижний предел, например, чтобы топливо не опускалось ниже нуля. Для этого добавим проверку в машину:

```c
void *car(void *arg) {
pthread_mutex_lock(&mutexFuel);
if (fuel >= 40) {
  fuel -= 40;
  printf("Потратил. Осталось топлива: %d\n", fuel);
} else {
  printf("Топлива недостаточно\n");
}
pthread_mutex_unlock(&mutexFuel);
}
```

```text
Топлива недостаточно
Добавлено топливо. Сейчас: 15
Добавлено топливо. Сейчас: 30
Добавлено топливо. Сейчас: 45
Добавлено топливо. Сейчас: 60
Добавлено топливо. Сейчас: 75
```

Теперь, как видно из вывода, машина вообще не может потратить топливо :(. Вместо проверки топлива один раз будем ждать и проверять топливо пока оно не появится.

```c
void *car(void *arg) {
pthread_mutex_lock(&mutexFuel);
while (fuel < 40) {
  printf("Топлива недостаточно. Ждем заправки\n");
}
fuel -= 40;
printf("Потратил. Осталось топлива: %d\n", fuel);
pthread_mutex_unlock(&mutexFuel);
}
```

Внимательный читатель предположит, что мы сейчас создали бесконечный цикл. И да, вы правы:

```text
Топлива недостаточно. Ждем заправки
Топлива недостаточно. Ждем заправки
Топлива недостаточно. Ждем заправки
Топлива недостаточно. Ждем заправки
...
```

Это связано с тем, что машина при проверке блокирует мьютекс и ждет в цикле пока топливо увеличится. А заправка в свою очередь заходит в свою функцию и ждет разблокировки мьютекса машиной, за счет чего никак не может добавить топливо.

Хотелось бы как то освободить мьютекс пока машина ждет и передать его заправке. Вот здесь нам и нужны **condition variables**. Они позволяют машине не просто ждать в активном цикле, а освободить мьютекс и перейти в спящее состояние, экономя ресурсы процессора.

Условные переменные в С имеют тип `pthread_cond_t`. Ознакомимся подробнее с доступными методами для работы с условными перменными.

<details>
<summary>
  pthread_cond_init() - Инициализация condition variable
</summary>

```c
int pthread_cond_init(pthread_cond_t *restrict cond,
                     const pthread_condattr_t *restrict attr);
```

**Параметры:**

- `cond` - **указатель** на структуру `pthread_cond_t` для инициализации
- `attr` - **атрибуты** (NULL для значений по умолчанию)

**Предназначение:**

- Динамическая инициализация condition variable
- Должна быть вызвана перед использованием

**Возвращает:**

- `0` - успех
- `EAGAIN` - недостаточно ресурсов системы
- `ENOMEM` - недостаточно памяти
- `EBUSY` - попытка переинициализации уже инициализированной condition variable
- `EINVAL` - неверные параметры (некорректные атрибуты)

</details>

<details>
<summary>
  pthread_cond_destroy() - Уничтожение condition variable
</summary>

**Сигнатура:**

```c
int pthread_cond_destroy(pthread_cond_t *cond);
```

**Параметры:**

- `cond` - **condition variable** для уничтожения

**Предназначение:**

- Освобождение ресурсов condition variable
- Должна быть вызвана когда condition variable больше не нужна

**Возвращает:**

- `0` - успех
- `EBUSY` - condition variable еще используется потоками (есть ожидающие)
- `EINVAL` - неверный параметр (cond не инициализирована или уже уничтожена)

</details>

<details>
<summary>
  PTHREAD_COND_INITIALIZER Статическая инициализация:
</summary>

```c
pthread_cond_t cond = PTHREAD_COND_INITIALIZER;
```

- Не требует вызова `pthread_cond_init()`
- Не требует вызова `pthread_cond_destroy()`

</details>

<details>
<summary>
  pthread_cond_wait() - Ожидание сигнала
</summary>

**Сигнатура:**

```c
int pthread_cond_wait(pthread_cond_t *restrict cond,
                     pthread_mutex_t *restrict mutex);
```

**Параметры:**

- `cond` - **condition variable** на которой ожидать
- `mutex` - **заблокированный мьютекс** который будет разблокирован

**Предназначение:**

- Разблокирует мьютекс и переходит в ожидание
- При получении сигнала автоматически перезахватывает мьютекс
- Эквивалентно:

     ```text
     pthread_mutex_unlock(&mutex);
     wait for signal;
     pthread_mutex_lock(&mutex);
     ```

**Возвращает:**

- `0` - успех (разбужен сигналом)
- `EINVAL` - неверные параметры (cond или mutex некорректны)
- `EPERM` - мьютекс не принадлежит текущему потоку

</details>

<details>
<summary>
  pthread_cond_timedwait() - Ожидание с таймаутом
</summary>

**Сигнатура:**

```c
int pthread_cond_timedwait(pthread_cond_t *restrict cond,
                          pthread_mutex_t *restrict mutex,
                          const struct timespec *restrict abstime);
```

**Параметры:**

- `cond` - **condition variable** для ожидания
- `mutex` - **заблокированный мьютекс**
- `abstime` - **абсолютное время** окончания ожидания

**Предназначение:**

- То же что и `pthread_cond_wait()`, но с ограничением по времени ожидания
- Полезно для избежания бесконечного ожидания

**Возвращает:**

- `0` - успех (разбужен сигналом)
- `ETIMEDOUT` - истек таймаут (заданное время достигнуто)
- `EINVAL` - неверные параметры (cond, mutex или время некорректны)
- `EPERM` - мьютекс не принадлежит текущему потоку

</details>

<details>
<summary>
  pthread_cond_signal() - Пробуждение одного потока
</summary>

**Сигнатура:**

```c
int pthread_cond_signal(pthread_cond_t *cond);
```

**Параметры:**

- `cond` - **condition variable** для отправки сигнала

**Предназначение:**

- Пробуждает **один** произвольный поток, ожидающий на condition variable
- Используется когда достаточно одного потока для обработки

**Возвращает:**

- `0` - успех
- `EINVAL` - неверный параметр (cond не инициализирована)

</details>

<details>
<summary>
  pthread_cond_broadcast() - Пробуждение всех потоков
</summary>

**Сигнатура:**

```c
int pthread_cond_broadcast(pthread_cond_t *cond);
```

**Параметры:**

- `cond` - **condition variable** для отправки сигнала

**Предназначение:**

- Пробуждает **все** потоки, ожидающие на condition variable
- Используется когда все ожидающие потоки должны проснуться

**Возвращает:**

- `0` - успех
- `EINVAL` - неверный параметр (cond не инициализирована)

</details>

Возвращаясь к нашему примеру, добавим условную перменную `pthread_cond_t condFuel`.

```c
pthread_mutex_t mutexFuel;
pthread_cond_t condFuel;
int fuel = 0;

pthread_t th[2];
pthread_mutex_init(&mutexFuel, NULL);
pthread_cond_init(&condFuel, NULL);
// код создания потоков
// код ожидания завершения потоков
pthread_mutex_destroy(&mutexFuel);
pthread_cond_destroy(&condFuel);
```

В цикле ожидания топлива в `car` воспользуемся `pthread_cond_wait()` для разлокировки мьютекса пока мы ждем.

```c
void *car(void *arg) {
  pthread_mutex_lock(&mutexFuel);
  while (fuel < 40) {
    printf("Топлива недостаточно. Ждем заправки\n");
    pthread_cond_wait(&condFuel, &mutexFuel); // Добавили ожидание сигнала
  }
  fuel -= 40;
  printf("Потратил. Осталось топлива: %d\n", fuel);
  pthread_mutex_unlock(&mutexFuel);
}
```

В коде заправки добавим отправку сигнала после заврешения заправки топлива:

```c
void *fuel_filling(void *arg) {
  for (int i = 0; i < 5; i++) {
    pthread_mutex_lock(&mutexFuel);
    fuel += 15;
    printf("Добавлено топливо. Сейчас: %d\n", fuel);
    pthread_cond_signal(&condFuel);  // Отправка сигнала машине
    pthread_mutex_unlock(&mutexFuel);
    sleep(1);
  }
}
```

Теперь наша программа отработает корректно и не зависнет. Полный код можете посмотреть в `src/condition_variable.c`

## Условные переменные. Бооольше потоков!

Все мы знаем что реальные заправки умеет обслуживать несколько машин, а не одну. Добавим в наш код больше потоков-машин.

```c
#define THREAD_COUNT 5

for (int i = 0; i < THREAD_COUNT; i++) {
  if (i == THREAD_COUNT - 1) {
    if (pthread_create(&th[i], NULL, fuel_filling, NULL) != 0) {
      perror("Failed to create thread");
    }
  } else {
    if (pthread_create(&th[i], NULL, car, NULL) != 0) {
      perror("Failed to create thread");
    }
  }
}
```

Вывод:

```text
Топлива недостаточно. Ждем заправки
Топлива недостаточно. Ждем заправки
Топлива недостаточно. Ждем заправки
Топлива недостаточно. Ждем заправки
Добавлено топливо. Сейчас: 15
Топлива недостаточно. Ждем заправки
Добавлено топливо. Сейчас: 30
Топлива недостаточно. Ждем заправки
Добавлено топливо. Сейчас: 45
Потратил. Осталось топлива: 5
Добавлено топливо. Сейчас: 20
Топлива недостаточно. Ждем заправки
Добавлено топливо. Сейчас: 35
Топлива недостаточно. Ждем заправки
```

И вот у нас снова что-то сломалось, программа зависла. Проясним вывод. У нас создается 4 машины и 1 заправщик. Все 4 машины одновременно захватывают мьютекс и проверяют условие `fuel < 40`. Поскольку изначально fuel = 0, все 4 машины переходят в состояние ожидания на condition variable, освобождая мьютекс.

Заправщик начинает работу, добавляет 15 единиц топлива и отправляет сигнал через `pthread_cond_signal()`. Вот здесь ключевая проблема: `pthread_cond_signal()` будит только **ОДНУ** случайную машину из четырех ожидающих.

Проснувшаяся машина проверяет условие - топлива 15, что все еще меньше 40, поэтому она снова засыпает. Остальные 3 машины вообще не просыпаются.

Заправщик продолжает добавлять по 15 единиц и каждый раз будит только одну машину, которая проверяет условие и снова засыпает. В результате у нас накапливается топливо (15, 30, 45...), но только одна машина об этом "знает", и то она видит что условия не выполнены.

Когда топлива становится 45, одна машина наконец-то может взять 40 единиц, но остальные 3 машины остаются в вечном сне - они никогда не получают сигнал для пробуждения, потому что `pthread_cond_signal()` будит только одну машину за раз, а после того как одна машина забрала топливо, заправщик уже закончил свою работу.

Вот почему программа зависает - три машины вечно ждут сигнала который никогда не придет.

Для решения данной проблемы во-первых изменим кол-во топливо подаваемое заправкой, чтобы она справилась с таким кол-вом машин за 5 итераций, например, установим 60 (либо можете попробовать добавить еще один поток-заправку). Во-вторых, использовать `pthread_cond_broadcast()` вместо `pthread_cond_signal()`, который разбудит **ВСЕ** ожидающие машины одновременно, чтобы каждая могла проверить условие и попробовать заправиться.

```c
void *fuel_filling(void *arg) {
  for (int i = 0; i < 5; i++) {
    pthread_mutex_lock(&mutexFuel);
    fuel += 60;
    printf("Добавлено топливо. Сейчас: %d\n", fuel);
    pthread_cond_broadcast(&condFuel);  // Отправка сигнала всем машинам
    pthread_mutex_unlock(&mutexFuel);
    sleep(1);
  }
}
```

Вывод:

```text
Топлива недостаточно. Ждем заправки
Топлива недостаточно. Ждем заправки
Топлива недостаточно. Ждем заправки
Топлива недостаточно. Ждем заправки
Добавлено топливо. Сейчас: 60
Потратил. Осталось топлива: 20
Топлива недостаточно. Ждем заправки
Топлива недостаточно. Ждем заправки
Топлива недостаточно. Ждем заправки
Добавлено топливо. Сейчас: 80
Потратил. Осталось топлива: 40
Потратил. Осталось топлива: 0
Топлива недостаточно. Ждем заправки
Добавлено топливо. Сейчас: 60
Потратил. Осталось топлива: 20
Добавлено топливо. Сейчас: 80
Добавлено топливо. Сейчас: 140
```

Изначально все 4 машины одновременно проверяют уровень топлива и обнаруживают, что его недостаточно для заправки. Каждая машина переходит в состояние ожидания, выводя сообщение: "Топлива недостаточно. Ждем заправки". Это демонстрирует правильную работу мьютекса - все машины корректно блокируются в ожидании условия.

Заправщик начинает свою работу, последовательно добавляя топливо. При первом добавлении уровень достигает 60 единиц, что достаточно для одной машины. Проснувшаяся машина забирает 40 единиц, оставляя 20 в резерве. Остальные три машины продолжают ожидание, так как оставшегося топлива недостаточно.

При последующих заправках мы наблюдаем интересную динамику: когда уровень топлива достигает 80 единиц, две машины успевают заправиться практически одновременно.

По мере выполнения программы количество ожидающих машин постепенно уменьшается. Все машины в конечном итоге получают необходимое топливо, что подтверждает отсутствие блокировок и голодания.
