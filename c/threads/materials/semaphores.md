# Семафор

**Семафор** – это объект, который используется для контроля доступа нескольких потоков до общего ресурса. В общем случае это какая-то переменная, состояние которой изменяется каждым из потоков. Текущее состояние переменной определяет доступ к ресурсам.

Принцип работы:

- Семафор имеет счетчик, который инициализируется начальным значением
- Когда поток хочет получить доступ к ресурсу, он уменьшает счетчик семафора (операция "wait")
- Если счетчик больше нуля - поток продолжает выполнение
- Если счетчик равен нулю - поток блокируется до тех пор, пока счетчик не станет положительным
- Когда поток освобождает ресурс, он увеличивает счетчик семафора (операция "post")

Представьте парковку с ограниченным количеством мест. Каждая машина (поток) занимает место (уменьшает счетчик), а когда уезжает - освобождает его (увеличивает счетчик). Если мест нет, новые машины ждут.

Для работы с семафорами в POSIX используется тип `sem_t`.

<details>
<summary>
sem_init() - Инициализация семафора
</summary>

```c
int sem_init(sem_t *sem, int pshared, unsigned int value);
```

**Параметры:**

- `sem` - **указатель** на структуру `sem_t` для инициализации
- `pshared` - **флаг разделения**:
  - `0` - семафор используется только между потоками одного процесса
  - ненулевое значение - семафор может использоваться между процессами
- `value` - **начальное значение** счетчика семафора

**Предназначение:**

- Инициализация неименованного семафора
- Устанавливает начальное значение счетчика
- Должна быть вызвана перед использованием семафора

**Возвращает:**

- `0` - успех
- `-1` - ошибка, `errno` устанавливается в:
  - `EINVAL` - значение `value` превышает `SEM_VALUE_MAX`
  - `ENOSYS` - система не поддерживает семафоры
  - `ENOTSUP` - неподдерживаемое значение `pshared`

</details>

<details>
<summary>
sem_destroy() - Уничтожение семафора
</summary>

**Сигнатура:**

```c
int sem_destroy(sem_t *sem);
```

**Параметры:**

- `sem` - **семафор** для уничтожения

**Предназначение:**

- Освобождение ресурсов семафора
- Должна быть вызвана, когда семафор больше не нужен
- Семафор не должен использоваться потоками во время уничтожения

**Возвращает:**

- `0` - успех
- `-1` - ошибка, `errno` устанавливается в:
  - `EINVAL` - неверный параметр (sem не инициализирован или уже уничтожен)
  - `EBUSY` - семафор еще используется потоками

</details>

<details>
<summary>
sem_wait() - Ожидание семафора (уменьшение счетчика)
</summary>

**Сигнатура:**

```c
int sem_wait(sem_t *sem);
```

**Параметры:**

- `sem` - **семафор** для ожидания

**Предназначение:**

- Атомарно уменьшает значение семафора на 1
- Если значение семафора больше 0 - поток продолжает выполнение
- Если значение равно 0 - поток блокируется до тех пор, пока значение не станет больше 0
- Используется для входа в критическую секцию или получения доступа к ресурсу

**Возвращает:**

- `0` - успех
- `-1` - ошибка, `errno` устанавливается в:
  - `EINVAL` - неверный параметр
  - `EINTR` - операция была прервана сигналом

</details>

<details>
<summary>
sem_trywait() - Неблокирующее ожидание семафора
</summary>

**Сигнатура:**

```c
int sem_trywait(sem_t *sem);
```

**Параметры:**

- `sem` - **семафор** для проверки

**Предназначение:**

- Неблокирующая версия `sem_wait()`
- Пытается атомарно уменьшить значение семафора на 1
- Если значение больше 0 - уменьшает и возвращает успех
- Если значение равно 0 - немедленно возвращает ошибку вместо блокировки

**Возвращает:**

- `0` - успех (счетчик уменьшен)
- `-1` - ошибка, `errno` устанавливается в:
  - `EAGAIN` - семафор уже заблокирован (значение = 0)
  - `EINVAL` - неверный параметр
  - `EINTR` - операция была прервана сигналом

</details>

<details>
<summary>
sem_post() - Освобождение семафора (увеличение счетчика)
</summary>

**Сигнатура:**

```c
int sem_post(sem_t *sem);
```

**Параметры:**

- `sem` - **семафор** для освобождения

**Предназначение:**

- Атомарно увеличивает значение семафора на 1
- Если есть потоки, заблокированные в `sem_wait()`, один из них разблокируется
- Используется для выхода из критической секции или освобождения ресурса

**Возвращает:**

- `0` - успех
- `-1` - ошибка, `errno` устанавливается в:
  - `EINVAL` - неверный параметр
  - `EOVERFLOW` - значение семафора превысило `SEM_VALUE_MAX`

</details>

<details>
<summary>
sem_getvalue() - Получение текущего значения семафора
</summary>

**Сигнатура:**

```c
int sem_getvalue(sem_t *sem, int *sval);
```

**Параметры:**

- `sem` - **семафор** для проверки
- `sval` - **указатель** для сохранения текущего значения

**Предназначение:**

- Получает текущее значение счетчика семафора
- Полезно для отладки и мониторинга

**Возвращает:**

- `0` - успех, значение сохранено в `sval`
- `-1` - ошибка, `errno` устанавливается в:
  - `EINVAL` - неверный параметр

**Примечание:** Полученное значение может быть устаревшим к моменту его использования, так как другие потоки могут изменить семафор.

</details>

<details>
<summary>
  Пример использования
</summary>

Представим, что мы пишем онлайн игру. Ресурсы сервера ограничены, поэтому не все желающие могут присоединиться к игре. Как мы можем организовать данную очередь? Конечно же использовать семафоры. Счетчик семафора будет равен максимальному количеству игроков, которое может вместить наш сервер. Пусть это будет 3 человека. А пользователей у нас будет 5.

Создадим семафор:

```c
#define THREAD_NUM 5
#define MAX_PLAYER_COUNT 3

sem_t semaphore;

int main() {
  pthread_t th[THREAD_NUM];
  sem_init(&semaphore, 0, MAX_PLAYER_COUNT);

  // код создания и ожидания потоков

  sem_destroy(&semaphore);
  return 0;
}
```

Предл входом в игру мы будем запускать метод `sem_wait`. Если свободные места есть, то мы войдем в игру, иначе будем ожидать выхода другого игрока. После завершения игры будем освобождать свое место. Потоки-игроки будут печатать свое состояние на экран:

```c
void* routine(void* args) {
  printf("(%d) Жду своей очереди!\n", *(int*)args);

  // Ожидает освобождения места, или занимает его, если место есть
  sem_wait(&semaphore);

  printf("(%d) Вошел в игру!\n", *(int*)args);
  sleep(rand() % 5 + 1); // Играет

  printf("(%d) Наигрался, выхожу из игры!\n", *(int*)args);

  // Освобождает место для других игроков
  sem_post(&semaphore);
  free(args);
}
```

**Вывод программы:**

```text
(0) Жду своей очереди!
(0) Вошел в игру!
(1) Жду своей очереди!
(1) Вошел в игру!
(3) Жду своей очереди!
(3) Вошел в игру!
(2) Жду своей очереди!
(1) Наигрался, выхожу из игры!
(2) Вошел в игру!
(3) Наигрался, выхожу из игры!
(2) Наигрался, выхожу из игры!
(0) Наигрался, выхожу из игры!
```

Как видно все отлично работает. Поток с ноемром 1 освободил игру и на его место вошел поток номер 2.

Полный код программы доступен в файле [src/semaphore.c](../src/semaphore.c)

</details>
