# Multiple and virtual inheritance

public/private

Derived -> Base
|casts      |copy |ptr  |ref  |
|-----------|-----|-----|-----|
|implicit   |OK/CE|OK/CE|OK/CE|
|static     |OK/CE|OK/CE|OK/CE|
|reinterpret|CE/CE|OK/CE|OK/CE|

Base -> Derived
|casts      |copy |ptr    |ref    |
|-----------|-----|-------|-------|
|implicit   |CE/CE|CE/CE  |CE/CE  |
|static     |CE/CE|[OK/CE]|[OK/CE]|
|reinterpret|CE/CE|[OK/OK]|[OK/OK]|

[ ] - imposible UB, конвертировать то смогли, но при обращении к полям может быть `UB`.

## Multiple inheritance

      Mom   Dad  
       ^     ^  
        \   /      
         Son     
```cpp
struct Mom {int m;};
struct Dad {int s;};
struct Son: Mom, Dad {int s;};
```

### Location in memory

|0x7ffecac8f81c|0x7ffecac8f820|...|
|--------------|--------------|---|
|m             |d             |s  |

При преобразовании указателя или ссылки наследника к указателю или ссылке базового класса `Ded`, то указатель сдвинется с начала объекта(адрес `m`)  на адрес `d`.

Если у обоих родителей есть метод `f()`, то будет перегрузка между ними. Аргументы могут быть разными. Если методы идентичны, то при добавлении их в область видимости `СЕ` не будет, но при их вызове будет `СЕ`(так же и с полями работает). Можно без проблем обращаться напрямую указав чью из родительских `f()` мы используем:
```cpp
Son s;
s.Ded::f();
```

###  Diamond problem(проблема ромбовидного наследования)

     Grendma
      /  \
    Mom  Ded
      \  /
      Son

На самом деле лучше изобразить картинку вот так:  

    Grendma  Grendma
       |       |
      Mom     Ded
        \     /
          Son

```cpp
struct Grandma {int g;}
struct Mom: Grandma {int m;};
struct Ded: Grandma {int d;};
struct Son: Mom, Ded {int s;};
```
Хранение в памяти:
|g|m|g|d|s|
|-|-|-|-|-|

Cколько будет весит структура `Son`?  
Ответ: 20 байт, т.к. поля структуры `Grandma` будут в структуре `Son` в двух экземплярах.

Все что рассказывается не зависит от приватности!  
1. Допустим в нашей структуре `Grandma` появился поле `gg`; 
Тогда при такой попытке будет `СЕ`(‘Grandma’ is an ambiguous base of ‘Son’):
```cpp
Son son;
son.gg // CE
son.Grandma::gg; // CE Да, так тоже нельзя
```
Но никто не запрещает обратится напрямую к `gg` через родиля:
```cpp
Son son;
son.Mom::gg
```

2. Cast  на прямую к бабушке тоже не получится:
```cpp
Grandma& g = son; // CE
static_cast<Mom::Grandma&>(son); // CE
```
А вот если сделать cast к Mom, а после к Grandma, то все ок.
```cpp
Son son;
Mom& mom = son;
Grandma& gr = mom;
```

3. Допустим у нашей `Grandma` есть метод `g()` - его нам использовать напрямую из `son` тоже не получится. Так как в методе могут использоваться поля конкретного класса/структуры. В зависимости от бабушки поля разные.

4. Пусть мы скастили `Son` к `Mom`. Можем ли мы скастить `Mom` к `Ded`?
Нет, так как в зависимости от объекта при касте нам надо делать либо сдиг вправо, либо сдвиг влево. Например:
```cpp
struct Doghter: Ded, Mom { int dd; };

В памяти - [d][m][dd]
```
В такой ситуации при касте из Mom нам нужно двигать указатель влево, а в случае с `Son` нам нужно было двигать вправо.

5. Cast от `Grandma` к `Son` тоже не определен. Можно от `Grandma` -> `Dad` -> `Son`, так работает.  

Представим такую ситуацию:

    Grandma 
       ^
       |
      Ded  Grendma
       ^     ^
        \   /
         Son

```cpp
struct Grandma { int g; };
struct Ded: Grandma {};
struct Son: Ded, Grandma {};
```
Как обратится к полю `g`?
Можно только руками со сдвигом указателей.
Вот так будет `CE`, так как не понятно к какой бабушке обращаться:
```cpp
Son s;
s.Grandma::g(); // CE
s.Dad::g() // но так все ОК
```

Вспомним указатель на методы и вернемся к классической картинке:    

      Mom   Dad  
       ^     ^  
        \   /      
         Son
```cpp
struct Ded { void f();};
struct Mom { void f();};
struct Son: Mom, Ded {};
```
Пусть у нас имеется указатель на метод `f()` структуры `Mom`. Что будет если мы попытаемся вызвать метод от объекта сына через этот указатель?
```cpp
void (Mom.*p)() = &f;
(s.*p)();
```
Ответ: Все будет хорошо ведь указатель на метод не будет сдвигаться при таком случае.

А если попробуем использовать `Dad` вместот `Mom`?
```cpp
void (Dad::*p)() = &f;
(s.*p)();
```
На самом деле указатель на метод еще хранит в себе сдвиг, по которому вызывается метод.
Указатель на метод: 
|ptr to method|shift|
|-------------|-----|
Изначально указатель `Ded::*p` хранит сдвиг 0. Но так как мы вызываемся от сына, то нужно произвести сдвиг.
```cpp
void (Ded::*p)() = &Son::f; // shift = 0
void (Son::*ps)() = &p; // shift становится  не 0
(s.*ps)();
```
Так мы изменяем сдвиг и вызываем нужный метод.

# $4.6 Virtual inheritance
Проблема ромбовидного наследования должна как то решаться. Для этого были создано виртуальное наследование.

    Grandma
      /  \
    Mom  Ded
      \  /
      Son
```cpp
struct Grandma { int g; };
struct Mom: virtual Grandma { int m; };
struct Ded: virtual Grandma { int d; };
struct Son: Mom, Ded { int s; };
```
Теперь все проблемы обращения к методам и полям `Grandma` решены. 
```cpp
Son s;
s.g; // OK
Grandma& gr = s; // OK
```
Но как это работает? И сколько теперь в памяти будет занимать `Son`?
Теперь в начале каждой структуры с виртуальным наследованием будет хранится указатель на таблицу сдвигов (таблица хранится в статической памяти). Для ясности посмотрим на хранение структур в памяти:
```
|ptr|m|ptr|d|s|g|
|---|-|---|-|-|-|
  |     |
  |     |
  |     \-> vtableDed: |12|
  |
  \-> vtableMom: |12|
      vtableSon: |32|
```

Итого: (ptr = 8б) + (m = 4б) + (выравнивание = 4б) +  (ptr = 8б) + (d = 4б) + (s = 4б) + (g = 4б) + (выравнивание = 4б) = 40б

В vtableDed и vtableMom хранится одинаковый сдвиг. Это связано с тем, что структуры Mom и Ded расположены одинаково относительно Grandma при их создании.

1. Static_cast от Son к Grandma работает хорошо. А в обратную сторону уже не получится. Допустим у нас еще есть наследник Son пусть будет внук. У внука сдвиг до бабушки должен быть больше 32. Если бы мы конвертировали из Son то мы бы сдвинули на 32 и все. Но у внука сдвиг больше 32 и при конвертации от `Grandma` к `Son` нам не понятно на сколько конкретно нам сдвинуться. Такой случай конвертации сверху вниз это CE.

2. Что если Mom будет с виртуальным наследованием, а Ded обычным наследованием. 
```cpp
struct Grandma {int g;};
struct Mom: virtual Grandma {int m;};
struct Ded: Grandma { int d;};
struct Son: Mom, Ded { int s;};
```

Тогда у нас будет все так же две Grandma: одна виртуальная в конце, а другая обычная(как и при обычном наследовании). По итогу проблема ромбовидного наследования остается не решенной:
|ptr|m|g|d|s|g|
|---|-|-|-|-|-|

3. Пусть мы не укажем что Grandma virtual, а укажем что Mom и Ded наследуются виртуально.
```cpp
struct Grandma {int g;};
struct Mom: Grandma {int m;};
struct Ded: Grandma { int d;};
struct Son: virtual Mom, virtual Ded { int s;};
```
Как это будет выглядить в памяти?
```
|ptr|s|g|m|g|d|
|---|-|-|-|-|-|
  |    ^   ^
  \->|shM|shD| shM -  сдвиг мамы, shD - сдвиг папы
     |---|---|
```
4. Представим такое наследование:
```
    W   V   W
     \ / \ /
      B   C
       \ /
        A
```
```cpp
struct W { void g(); };
struct V { void f(); };
struct B: W, virtual V { void f(); void g(); };
struct C: W, virtual V {};
struct A: B, C {};
```
При виртуальном наследовании у нас возникают случаи когда по графу методов  мы можем достигнуть метода с одним и тем же названием несколькими способами. Поэтому стандартом принято, что выбирается ближайший метод в графе. В нашем примере это метод f() и ближайший из структуры B.   
А вызов метода g() уже не однозначен так как мы можем дойти несколькими путями при не виртуальном наследовании.

