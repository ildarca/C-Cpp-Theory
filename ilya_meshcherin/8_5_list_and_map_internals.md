`std::map` -  упорядоченный ассоциативный массив.
В основе лежит красно-черное дерево.
Операции:
`pair<iterator, bool> insert(const pair<Key,Value>&);`
`size_t erase(Key);`
`Value& at(Key);`
`const Value& at(Key) const;`
`Value& operator[](Key);`
`iterator erase(iterator);`
`iterator find(Key);`

Все эти функции работают за `O(log n)`

Почему фигурные скобочки не константные?
Это значит их нельзя использовать для константных объектов.  
Связано с тем, что `operator[]` в `std::map` создает объект по ключу если его нет, а константный `std::map` мы менять не можем и не должны.

`size_t count(Key);` - Выдает количество элементом с ключем `Key`. Выдает `0` или `1`.

Неэффективный способ его использования:
```
if (m.count(2)) {
  m[2] = 5;
}
```
В таком случае мы два разаа будет спускаться по дереву:
1. Проверить существования ключа `2`.
2. Присовение по ключу `2` значение `5`.

Более эффективный способ:
```
if (auto& it = m.find(1), it != m.end()) {
  it->second = 2;
}
```

Перейдем к реализации:
```
template <typenme Key, typename Value>
class map {
  struct Node {
    std::pair<Key, Value> kv;
    Node* left;
    Node* right;
    Node* parent; 
    // родитель нужен так как нужно ходить итератором вверх
    bool red;
  };
};
```

У официального `map` мы можем брать итератор на `end`. Из-за чего наши итераторы должны уметь перемещаться назад. За счет чего возникает некоторые трудности и наша первичная реализация не подойдет.  
Для другой реализации предлагается использование фейковой ноды:
```
           +---------+    +------------+
           |fake Node| <- |end iterator|
           +---------+    +------------+
              /   \
             /     \
            /       x
           /\
          /  \
         /    \
        /      \
       / дерево \
      /          \
     +------------+
     ^
     |
  +-------------+
  |begin terator|
  +-------------+
```
Реализация с фейк нодой:
```
template <typename Key, typename Value>
class map {

  struct BaseNode {
    Node* left;
    Node* right;
    Node* parent;
  };

  struct Node: BaseNode {
    std::parent<const Key, Value> kv; 
    bool red;
  };
};
```
Почему `Key` является `const`?
Если бы мы так нее сделали, то пользователь мог бы изменять значение ключа. Но это бы лолмало упорядоченность дерева:
Пример такой ситации:
```
auto it = m.find(5);
it->first = 0;
```

Есть частая ошибка при использование `range-for` не учитывая константность:
```
for (const pair<int, std::string>& p : m) {
  // чет делаем
}
```
Здесь будет происходить копирование так как итератор на `map` будет возвращать `pair<const int, std::string>`. И за счет этого будет создаваться временная пара `pair<int, std::string>`. Что и дает нам копирование.
Поэтому лучше писать так:
```
for (auto p : m) {
  // чет делаем
}
```
За счет `const` мы не можем вызывать алгоритмы изменияющие`map` саму себя. Наприме, просто присвоить одному значению из меп другое значение из того же мепа.

`lower_bound(Key)` - возвращает элемент меньше или равного данному.
`upper_bound(Key)`- возвращает элемент строго больше данного.

Немного доработанная структура `map`:
```
template <typename Key, typename Value, typename Compare=std::less<Key>>
class map {
  BaseNode* fakeNode;
  BaseNode* begin; // для быстрого доступа к начальному итератору
  size_t sz;
  Compare comp; // компоратор для сравнения
  struct BaseNode {
    Node* left;
    Node* right;
    Node* parent;
  };

  struct Node: BaseNode {
    std::parent<const Key, Value> kv; 
    bool red;
  };
};
```
# Exceptions safety
`List` - гарантирует, что при возникновении исключения во время создания нового объекта, объект будет возвращен в исходное состояние - до добавления элемента.
`Map` - дает те же гарантии, но тут мешает немного компоратор. Ведь он тоже может кинуть исключение во время сравнения. В красно-черных деревьях нужно делать повороты после сравнений. Это говорит о том, что если мы сравнивали и компоратор кинул исключение, то дерево еще никак не изменено,что спасает нас в этой ситуации.

