# $ 8.6 std::list internals
`std::list` - двунаправленный связный список, состоящий из нод. Каждая нода хранит значение и указатель на следующую и предыдущую ноду.
```
+----+   +----+   +----+  
|    | → |    | → |    |
|    | ← |    | ← |    |
+----+   +----+   +----+
```

Основные операции:
`insert(iterator it, const T& value);` 
`erase(iterator it);` 
`push_back/pop_back;` 
`push_front/pop_front;` 
`size();` 

Все эти функции работают за `O(1)` 
В `std::list` используется  `Bidirectional iterator`.

## Как реализовать?
```cpp
template <typename T>
class list {
  struct Node {
    T value;
    Node *next;
    Node *prev;
  };
  Node* head;
  Node* tail;
  size_t sz;
};
```

Жизнь усложняется как только у нас появляются итераторы.
```
+----+   +----+   +----+  
|    | → |    | → |    |
|    | ← |    | ← |    |
+----+   +----+   +----+
  ↑                  ↑                 
 head               tail
```
Мы должны уметь декрементировать итератор на конец `list` для любого `list`. 
Но в нашей реализации это сделать трудно. Для удобства добавим `fake` ноду. На которую и будет указывать итератор `end`.
```
+----+   +----+   +----+  
|    | → |    | → |    |
|    | ← |    | ← |    |
+----+   +----+   +----+
      ↖↘        ↙↗                
  ↑      +----+
 begin   |fake|
         |node|
         +----+
            ↑
           end
 ```
И при пустом списке итераторы будут указывать следующим образом:
```
        +----+
begin → |fake|
        |node|
        +----+
           ↑
          end
```
Теперь нам не надо хранить `head` и `tail`.Реализация примет вид:
```cpp
template <typename T>
class list {
  struct Node {
    T value;
    Node *next;
    Node *prev;
  };
  Node* beg;
  size_t sz;
};
```

Обратим внимание на еще одну проблему. Как инициализировать `T value` в фейковой пустой ноде. Почему бы не использовать указатель на `T` вместо самого значения? Для хранения через указатель нужно вызывать `new`. Список медленный сам по себе, а дополнительный вызов `new` для объекта `T` замедлит его еще сильнее.

Предлагается следующая идея: необходимо сделать две внутренние структуры. Одна будет хранить только указатели на предыдуий и следующий элементы, а вторая будет наследницей первой и будет хранить значение.
Первая:
```cpp
struct BaseNode {
  BaseNode* prev;
  BaseNode* next;
};
```
Вторая:
```cpp
struct Node : BaseNode {
  T value;
};
```

И сам список будет иметь вид:
```cpp
template <typename T>
class list {
  struct BaseNode {
    BaseNode* prev;
    BaseNode* next;
  };
  struct Node : BaseNode {
    T value;
  };
  BaseNode* fakeNode;
  size_t sz;
};
```

Чем изначально инициализировать `fakeNode`? Что должен делать конструктор по умолчанию `list()`? Пустой лист не должен аллоцировать память и итераторы должны быть корректными, но разыменовывать их нельзя. Давайте будем хранить не указатель на `fakeNode`, а саму `fakeNode` на стеке.
```cpp
template <typename T>
class list {
  struct BaseNode {
    BaseNode* prev;
    BaseNode* next;
  };
  struct Node : BaseNode {
    T value;
  };
  BaseNode fakeNode; // здесь изменили
  size_t sz;
};
```
Тогда пустой лист это `fakeNode`, хранящая указатели на саму себя. И конструктор по умолчанию будет иметь вид:
```cpp
list()
  : fakeNode{this, this},
    sz(0) {
}
```
Или по красивому:
```cpp
list() 
  : fakeNode{&fakeNode, &fakeNode},
    sz(0) {
}
```

### Необычные методы std::list
1. `sort()` - свой метод сортировки. Функция `sort()` из стандартной библиотеки не поддерживает список, так как для него нужен `RandomAccess` итератор. А список предлагает только `Bidirectional` итератор. Внутри метода сортировки списка лежит сортировка слиянием.
2. `merge()` - объединение двух списков
3. `splice(it, from, to)` - позволяет взять часть другого списка и добавить в текущий(если это один и тот же список то операция работает за `O(1)`, а если разные списки, то за `O(to-from)`):
```
+--+--+--*--+--*--+--+
|  |  |  |  |  |  |  |
+--+--+--*--+--*--+--+
         \     /
          \   /
           \ /
            ↓
+--+--+--+--*--+--+
|  |  |  |  |  |  |
+--+--+--+--*--+--+
```

## std::forward_list (C++11)
Нет `push_back();`, `pop_back();`, `size();`, `insert();`. На замену `insert()` есть `insert_after()`. `insert()` вставляет на то место куда мы передали, а в `forward_list` мы не знаем предыдущий элемент, чтобы вставить в переданное место, поэтому вставка происходит после переданного места.

# std::map
`std::map` -  упорядоченный ассоциативный массив.
В основе лежит красно-черное дерево.
Операции:  
`pair<iterator, bool> insert(const pair<Key,Value>&);`  
`size_t erase(Key);`  
`Value& at(Key);`  
`const Value& at(Key) const;`  
`Value& operator[](Key);`  
`iterator erase(iterator);`  
`iterator find(Key);`  

Все эти функции работают за `O(log n)`

Почему квадратные скобочки не константные?  
Это значит их нельзя использовать для константных объектов.  
Связано с тем, что `operator[]` в `std::map` создает объект по ключу если его нет, а константный `std::map` мы менять не можем и не должны.

`size_t count(Key);` - выдает существует ли элемент с ключем `Key`. Выдает `0` или `1`.

Неэффективный способ его использования:
```cpp
if (m.count(2)) {
  m[2] = 5;
}
```
В таком случае мы два раза будет спускаться по дереву:
1. Проверить существования ключа `2`.
2. Присовение по ключу `2` значение `5`.

Более эффективный способ:
```cpp
if (auto& it = m.find(2), it != m.end()) {
  it->second = 5;
}
```

Перейдем к реализации:
```cpp
template <typenme Key, typename Value>
class map {
  struct Node {
    std::pair<Key, Value> kv;
    Node* left;
    Node* right;
    Node* parent; 
    // родитель нужен так как нужно уметь ходить итератором вверх
    bool red;
  };
};
```

У официального `map` мы можем брать итератор на `end`. Из-за чего наши итераторы должны уметь перемещаться назад. За счет чего возникает некоторые трудности и наша первичная реализация не подойдет.  
Для другой реализации предлагается использование фейковой ноды:
```
           +---------+    +------------+
           |fake Node| <- |end iterator|
           +---------+    +------------+
              /   \
             /     \
            /       x
           /\
          /  \
         /    \
        /      \
       / дерево \
      /          \
     +------------+
     ^
     |
  +-------------+
  |begin terator|
  +-------------+
```
Реализация с фейк нодой:
```cpp
template <typename Key, typename Value>
class map {

  struct BaseNode {
    Node* left;
    Node* right;
    Node* parent;
  };

  struct Node: BaseNode {
    std::parent<const Key, Value> kv; 
    bool red;
  };
};
```
Почему `Key` является `const`?
Если бы мы так нее сделали, то пользователь мог бы изменять значение ключа. Но это бы ломало упорядоченность дерева:
Пример такой ситации:
```cpp
auto it = m.find(5);
it->first = 0;
```

Есть частая ошибка при использование `range-for` не учитывая константность:
```cpp
for (const pair<int, std::string>& p : m) {
  // чет делаем
}
```
Здесь будет происходить копирование так как итератор на `map` будет возвращать `pair<const int, std::string>`. И за счет этого будет создаваться временная пара `pair<int, std::string>`. Что и дает нам копирование.
Поэтому лучше писать так:
```cpp
for (auto p : m) {
  // чет делаем
}
```
За счет `const` мы не можем вызывать алгоритмы изменияющие`map` саму себя. Наприме, просто присвоить одному значению из меп другое значение из того же мепа.

`lower_bound(Key)` - возвращает элемент меньше или равного данному.
`upper_bound(Key)`- возвращает элемент строго больше данного.

Немного доработанная структура `map`:
```cpp
template <typename Key, typename Value, typename Compare=std::less<Key>>
class map {
  BaseNode* fakeNode;
  BaseNode* begin; // для быстрого доступа к начальному итератору
  size_t sz;
  Compare comp; // компоратор для сравнения
  struct BaseNode {
    Node* left;
    Node* right;
    Node* parent;
  };

  struct Node: BaseNode {
    std::parent<const Key, Value> kv; 
    bool red;
  };
};
```

# Exceptions safety
`List` - гарантирует, что при возникновении исключения во время создания нового объекта, объект будет возвращен в исходное состояние - до добавления элемента.

`Map` - дает те же гарантии, но тут мешает немного компоратор. Ведь он тоже может кинуть исключение во время сравнения. В красно-черных деревьях нужно делать повороты после сравнений. Это говорит о том, что если мы сравнивали и компоратор кинул исключение, то дерево еще никак не изменено,что спасает нас в этой ситуации.

