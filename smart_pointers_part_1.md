## Проблема ручного управления

Допупстим код должен выделить некий ресурс и корректно освободить его
```cpp
int foo(int x, double y) {
  MyRes *ptr = new MyRes(x, y);
  // ...
  if (/* какое-то условие */) {
    delete ptr;
    return -1;
  }
  // ...

  delete ptr;
  return 0;
}
```

Очевидно, что эта система довольна хрупкая. Что если три ресурса? Пять точек выхода? А что делать при исключениях?

## Идея решения: обертка над ресурсом

```cpp
int foo(int x, double y) {
  dumb_ptr<MyRes> res(new MyRes(x, y));  // выделение и захват
  // ...
  if (/* какое-то условие */) {
    return -1;  // память освобождается в деструкторе
  }
  // ...

  return 0;  // освобождение памяти
}
```
Теперь система куда симпатичней и требует от программмиста куда меньше держать в голове.

Напишем реализацию:
```cpp
template <typename T>
class dumb_ptr {
  T* ptr_;
 public:
  dumb_ptr(T* ptr = nullptr) : ptr_(ptr){}
  ~dumb_ptr {delete ptr};
  T operator*() const { return *ptr_; }
  T* operator->() const { return ptr_; }
};
```
В этом коде есть неочевидная проблема, связанная с генерацией компилятора конструктора копирования и оператора копирования по умолчанию.
Проблема в том, что тогда у нас может возникнуть двойное освобождение памяти, если оба наших объекьта класса управляют одним ресурсом.
Пример проболемы:
```cpp
dumb_ptr<int> ptr1(new int(42));
dumb_ptr<int> ptr2 = ptr1;
```
```
+----+     +----+
|ptr1|     |ptr2|
+----+     +----+
  |           |
  |   +---+   |
  \-> |int| <-/
      +---+
```

Решение проблемы:
Первый вариант - запретить копирование вообще
```cpp
template <typename T>
class scoped_ptr {
  // тут то же самое, что и в dumd_ptr

  scoped_ptr(const scoped_ptr&) = delete;
  scoped_ptr& operator=(const scoped_ptr&) = delete;
};
```
Это решает исходную проблему, но не позволяет выносить ресурс за пределы его области видимости.

Можем добавить метод для получения сырого указателя. За счет чего сможем передавать в различные скоупы ресурс. Но тогда для этого указателя кто-то может вызвать `delete`.

Древний выход из положения: auto_ptr

`auto_ptr` был введен в 98-м стандарте для передачи и владения ресурсом.
```cpp
template <typename T> auto_ptr {
  T* ptr_;
 public:
  auto_ptr(T* ptr = nullptr) : ptr_(ptr) {}
  ~auto_ptr() { delete ptr; }

};
```
